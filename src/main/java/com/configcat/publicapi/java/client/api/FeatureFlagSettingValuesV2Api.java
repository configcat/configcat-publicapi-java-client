/*
 * ConfigCat Public Management API
 * The purpose of this API is to access the ConfigCat platform programmatically. You can **Create**, **Read**, **Update** and **Delete** any entities like **Feature Flags, Configs, Environments** or **Products** within ConfigCat.  **Base API URL**: https://api.configcat.com  If you prefer the swagger documentation, you can find it here: [Swagger UI](https://api.configcat.com/swagger).  The API is based on HTTP REST, uses resource-oriented URLs, status codes and supports JSON  format.   **Important:** Do not use this API for accessing and evaluating feature flag values. Use the [SDKs](https://configcat.com/docs/sdk-reference/overview) or the [ConfigCat Proxy](https://configcat.com/docs/advanced/proxy/proxy-overview/) instead.  # OpenAPI Specification  The complete specification is publicly available in the following formats:  - [OpenAPI v3](https://api.configcat.com/docs/v1/swagger.json) - [Swagger v2](https://api.configcat.com/docs/v1/swagger.v2.json)  You can use it to generate client libraries in various languages with [OpenAPI Generator](https://github.com/OpenAPITools/openapi-generator) or [Swagger Codegen](https://swagger.io/tools/swagger-codegen/) to interact with this API.  # Authentication This API uses the [Basic HTTP Authentication Scheme](https://en.wikipedia.org/wiki/Basic_access_authentication).   <!-- ReDoc-Inject: <security-definitions> -->  # Throttling and rate limits All the rate limited API calls are returning information about the current rate limit period in the following HTTP headers:  | Header | Description | | :- | :- | | X-Rate-Limit-Remaining | The maximum number of requests remaining in the current rate limit period. | | X-Rate-Limit-Reset     | The time when the current rate limit period resets.        |  When the rate limit is exceeded by a request, the API returns with a `HTTP 429 - Too many requests` status along with a `Retry-After` HTTP header.
 *
 * The version of the OpenAPI document: v1
 * Contact: support@configcat.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.configcat.publicapi.java.client.api;


import com.configcat.publicapi.java.client.ApiCallback;
import com.configcat.publicapi.java.client.ApiClient;
import com.configcat.publicapi.java.client.ApiException;
import com.configcat.publicapi.java.client.ApiResponse;
import com.configcat.publicapi.java.client.Configuration;
import com.configcat.publicapi.java.client.Pair;
import com.configcat.publicapi.java.client.model.ConfigSettingFormulasModel;
import com.configcat.publicapi.java.client.model.JsonPatchOperation;
import com.configcat.publicapi.java.client.model.SettingFormulaModel;
import com.configcat.publicapi.java.client.model.UpdateEvaluationFormulaModel;
import com.configcat.publicapi.java.client.model.UpdateEvaluationFormulasModel;
import com.google.gson.reflect.TypeToken;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

public class FeatureFlagSettingValuesV2Api {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public FeatureFlagSettingValuesV2Api() {
        this(Configuration.getDefaultApiClient());
    }

    public FeatureFlagSettingValuesV2Api(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for getSettingValueV2
     *
     * @param environmentId The identifier of the Environment. (required)
     * @param settingId The id of the Setting. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> When everything is ok, the setting value data returned. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Bad request. </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Not found. </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests. In case of the request rate exceeds the rate limits. </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call getSettingValueV2Call(
            UUID environmentId, Integer settingId, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath =
                "/v2/environments/{environmentId}/settings/{settingId}/value"
                        .replace(
                                "{" + "environmentId" + "}",
                                localVarApiClient.escapeString(environmentId.toString()))
                        .replace(
                                "{" + "settingId" + "}",
                                localVarApiClient.escapeString(settingId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"Basic"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSettingValueV2ValidateBeforeCall(
            UUID environmentId, Integer settingId, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'environmentId' is set
        if (environmentId == null) {
            throw new ApiException(
                    "Missing the required parameter 'environmentId' when calling"
                            + " getSettingValueV2(Async)");
        }

        // verify the required parameter 'settingId' is set
        if (settingId == null) {
            throw new ApiException(
                    "Missing the required parameter 'settingId' when calling"
                            + " getSettingValueV2(Async)");
        }

        return getSettingValueV2Call(environmentId, settingId, _callback);
    }

    /**
     * Get value This endpoint returns the value of a Feature Flag or Setting in a specified
     * Environment identified by the &#x60;environmentId&#x60; parameter. The most important fields
     * in the response are the &#x60;defaultValue&#x60;, &#x60;targetingRules&#x60;, and
     * &#x60;percentageEvaluationAttribute&#x60;. The &#x60;defaultValue&#x60; represents what the
     * clients will get when the evaluation requests of our SDKs are not matching to any of the
     * defined Targeting Rules, or when there are no additional rules to evaluate. The
     * &#x60;targetingRules&#x60; represents the current Targeting Rule configuration of the actual
     * Feature Flag or Setting in an **ordered** collection, which means the order of the returned
     * rules is matching to the evaluation order. You can read more about these rules
     * [here](https://configcat.com/docs/targeting/targeting-overview/). The
     * &#x60;percentageEvaluationAttribute&#x60; represents the custom [User
     * Object](https://configcat.com/docs/targeting/user-object/) attribute that must be used for
     * [percentage evaluation](https://configcat.com/docs/targeting/percentage-options/) of the
     * Feature Flag or Setting.
     *
     * @param environmentId The identifier of the Environment. (required)
     * @param settingId The id of the Setting. (required)
     * @return SettingFormulaModel
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> When everything is ok, the setting value data returned. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Bad request. </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Not found. </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests. In case of the request rate exceeds the rate limits. </td><td>  -  </td></tr>
     * </table>
     */
    public SettingFormulaModel getSettingValueV2(UUID environmentId, Integer settingId)
            throws ApiException {
        ApiResponse<SettingFormulaModel> localVarResp =
                getSettingValueV2WithHttpInfo(environmentId, settingId);
        return localVarResp.getData();
    }

    /**
     * Get value This endpoint returns the value of a Feature Flag or Setting in a specified
     * Environment identified by the &#x60;environmentId&#x60; parameter. The most important fields
     * in the response are the &#x60;defaultValue&#x60;, &#x60;targetingRules&#x60;, and
     * &#x60;percentageEvaluationAttribute&#x60;. The &#x60;defaultValue&#x60; represents what the
     * clients will get when the evaluation requests of our SDKs are not matching to any of the
     * defined Targeting Rules, or when there are no additional rules to evaluate. The
     * &#x60;targetingRules&#x60; represents the current Targeting Rule configuration of the actual
     * Feature Flag or Setting in an **ordered** collection, which means the order of the returned
     * rules is matching to the evaluation order. You can read more about these rules
     * [here](https://configcat.com/docs/targeting/targeting-overview/). The
     * &#x60;percentageEvaluationAttribute&#x60; represents the custom [User
     * Object](https://configcat.com/docs/targeting/user-object/) attribute that must be used for
     * [percentage evaluation](https://configcat.com/docs/targeting/percentage-options/) of the
     * Feature Flag or Setting.
     *
     * @param environmentId The identifier of the Environment. (required)
     * @param settingId The id of the Setting. (required)
     * @return ApiResponse&lt;SettingFormulaModel&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> When everything is ok, the setting value data returned. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Bad request. </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Not found. </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests. In case of the request rate exceeds the rate limits. </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<SettingFormulaModel> getSettingValueV2WithHttpInfo(
            UUID environmentId, Integer settingId) throws ApiException {
        okhttp3.Call localVarCall =
                getSettingValueV2ValidateBeforeCall(environmentId, settingId, null);
        Type localVarReturnType = new TypeToken<SettingFormulaModel>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get value (asynchronously) This endpoint returns the value of a Feature Flag or Setting in a
     * specified Environment identified by the &#x60;environmentId&#x60; parameter. The most
     * important fields in the response are the &#x60;defaultValue&#x60;,
     * &#x60;targetingRules&#x60;, and &#x60;percentageEvaluationAttribute&#x60;. The
     * &#x60;defaultValue&#x60; represents what the clients will get when the evaluation requests of
     * our SDKs are not matching to any of the defined Targeting Rules, or when there are no
     * additional rules to evaluate. The &#x60;targetingRules&#x60; represents the current Targeting
     * Rule configuration of the actual Feature Flag or Setting in an **ordered** collection, which
     * means the order of the returned rules is matching to the evaluation order. You can read more
     * about these rules [here](https://configcat.com/docs/targeting/targeting-overview/). The
     * &#x60;percentageEvaluationAttribute&#x60; represents the custom [User
     * Object](https://configcat.com/docs/targeting/user-object/) attribute that must be used for
     * [percentage evaluation](https://configcat.com/docs/targeting/percentage-options/) of the
     * Feature Flag or Setting.
     *
     * @param environmentId The identifier of the Environment. (required)
     * @param settingId The id of the Setting. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> When everything is ok, the setting value data returned. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Bad request. </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Not found. </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests. In case of the request rate exceeds the rate limits. </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call getSettingValueV2Async(
            UUID environmentId, Integer settingId, final ApiCallback<SettingFormulaModel> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                getSettingValueV2ValidateBeforeCall(environmentId, settingId, _callback);
        Type localVarReturnType = new TypeToken<SettingFormulaModel>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getSettingValuesV2
     *
     * @param configId The identifier of the Config. (required)
     * @param environmentId The identifier of the Environment. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> When everything is ok, the setting values returned. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Bad request. </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Not found. </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests. In case of the request rate exceeds the rate limits. </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call getSettingValuesV2Call(
            UUID configId, UUID environmentId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath =
                "/v2/configs/{configId}/environments/{environmentId}/values"
                        .replace(
                                "{" + "configId" + "}",
                                localVarApiClient.escapeString(configId.toString()))
                        .replace(
                                "{" + "environmentId" + "}",
                                localVarApiClient.escapeString(environmentId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"Basic"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSettingValuesV2ValidateBeforeCall(
            UUID configId, UUID environmentId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'configId' is set
        if (configId == null) {
            throw new ApiException(
                    "Missing the required parameter 'configId' when calling"
                            + " getSettingValuesV2(Async)");
        }

        // verify the required parameter 'environmentId' is set
        if (environmentId == null) {
            throw new ApiException(
                    "Missing the required parameter 'environmentId' when calling"
                            + " getSettingValuesV2(Async)");
        }

        return getSettingValuesV2Call(configId, environmentId, _callback);
    }

    /**
     * Get values This endpoint returns all Feature Flag and Setting values of a Config identified
     * by the &#x60;configId&#x60; parameter in a specified Environment identified by the
     * &#x60;environmentId&#x60; parameter. The most important fields in the response are the
     * &#x60;defaultValue&#x60;, &#x60;targetingRules&#x60;. The &#x60;defaultValue&#x60; represents
     * what the clients will get when the evaluation requests of our SDKs are not matching to any of
     * the defined Targeting Rules, or when there are no additional rules to evaluate. The
     * &#x60;targetingRules&#x60; represents the current Targeting Rule configuration of the actual
     * Feature Flag or Setting in an **ordered** collection, which means the order of the returned
     * rules is matching to the evaluation order. You can read more about these rules
     * [here](https://configcat.com/docs/targeting/targeting-overview/). The
     * &#x60;percentageEvaluationAttribute&#x60; represents the custom [User
     * Object](https://configcat.com/docs/targeting/user-object/) attribute that must be used for
     * [percentage evaluation](https://configcat.com/docs/targeting/percentage-options/) of the
     * Feature Flag or Setting.
     *
     * @param configId The identifier of the Config. (required)
     * @param environmentId The identifier of the Environment. (required)
     * @return ConfigSettingFormulasModel
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> When everything is ok, the setting values returned. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Bad request. </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Not found. </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests. In case of the request rate exceeds the rate limits. </td><td>  -  </td></tr>
     * </table>
     */
    public ConfigSettingFormulasModel getSettingValuesV2(UUID configId, UUID environmentId)
            throws ApiException {
        ApiResponse<ConfigSettingFormulasModel> localVarResp =
                getSettingValuesV2WithHttpInfo(configId, environmentId);
        return localVarResp.getData();
    }

    /**
     * Get values This endpoint returns all Feature Flag and Setting values of a Config identified
     * by the &#x60;configId&#x60; parameter in a specified Environment identified by the
     * &#x60;environmentId&#x60; parameter. The most important fields in the response are the
     * &#x60;defaultValue&#x60;, &#x60;targetingRules&#x60;. The &#x60;defaultValue&#x60; represents
     * what the clients will get when the evaluation requests of our SDKs are not matching to any of
     * the defined Targeting Rules, or when there are no additional rules to evaluate. The
     * &#x60;targetingRules&#x60; represents the current Targeting Rule configuration of the actual
     * Feature Flag or Setting in an **ordered** collection, which means the order of the returned
     * rules is matching to the evaluation order. You can read more about these rules
     * [here](https://configcat.com/docs/targeting/targeting-overview/). The
     * &#x60;percentageEvaluationAttribute&#x60; represents the custom [User
     * Object](https://configcat.com/docs/targeting/user-object/) attribute that must be used for
     * [percentage evaluation](https://configcat.com/docs/targeting/percentage-options/) of the
     * Feature Flag or Setting.
     *
     * @param configId The identifier of the Config. (required)
     * @param environmentId The identifier of the Environment. (required)
     * @return ApiResponse&lt;ConfigSettingFormulasModel&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> When everything is ok, the setting values returned. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Bad request. </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Not found. </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests. In case of the request rate exceeds the rate limits. </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<ConfigSettingFormulasModel> getSettingValuesV2WithHttpInfo(
            UUID configId, UUID environmentId) throws ApiException {
        okhttp3.Call localVarCall =
                getSettingValuesV2ValidateBeforeCall(configId, environmentId, null);
        Type localVarReturnType = new TypeToken<ConfigSettingFormulasModel>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get values (asynchronously) This endpoint returns all Feature Flag and Setting values of a
     * Config identified by the &#x60;configId&#x60; parameter in a specified Environment identified
     * by the &#x60;environmentId&#x60; parameter. The most important fields in the response are the
     * &#x60;defaultValue&#x60;, &#x60;targetingRules&#x60;. The &#x60;defaultValue&#x60; represents
     * what the clients will get when the evaluation requests of our SDKs are not matching to any of
     * the defined Targeting Rules, or when there are no additional rules to evaluate. The
     * &#x60;targetingRules&#x60; represents the current Targeting Rule configuration of the actual
     * Feature Flag or Setting in an **ordered** collection, which means the order of the returned
     * rules is matching to the evaluation order. You can read more about these rules
     * [here](https://configcat.com/docs/targeting/targeting-overview/). The
     * &#x60;percentageEvaluationAttribute&#x60; represents the custom [User
     * Object](https://configcat.com/docs/targeting/user-object/) attribute that must be used for
     * [percentage evaluation](https://configcat.com/docs/targeting/percentage-options/) of the
     * Feature Flag or Setting.
     *
     * @param configId The identifier of the Config. (required)
     * @param environmentId The identifier of the Environment. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> When everything is ok, the setting values returned. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Bad request. </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Not found. </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests. In case of the request rate exceeds the rate limits. </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call getSettingValuesV2Async(
            UUID configId,
            UUID environmentId,
            final ApiCallback<ConfigSettingFormulasModel> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                getSettingValuesV2ValidateBeforeCall(configId, environmentId, _callback);
        Type localVarReturnType = new TypeToken<ConfigSettingFormulasModel>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postSettingValuesV2
     *
     * @param configId The identifier of the Config. (required)
     * @param environmentId The identifier of the Environment. (required)
     * @param updateEvaluationFormulasModel (required)
     * @param reason The reason note for the Audit Log if the Product&#39;s \&quot;Config changes
     *     require a reason\&quot; preference is turned on. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> When everything is ok, the updated setting values returned. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Bad request. </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Not found. </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests. In case of the request rate exceeds the rate limits. </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call postSettingValuesV2Call(
            UUID configId,
            UUID environmentId,
            UpdateEvaluationFormulasModel updateEvaluationFormulasModel,
            String reason,
            final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updateEvaluationFormulasModel;

        // create path and map variables
        String localVarPath =
                "/v2/configs/{configId}/environments/{environmentId}/values"
                        .replace(
                                "{" + "configId" + "}",
                                localVarApiClient.escapeString(configId.toString()))
                        .replace(
                                "{" + "environmentId" + "}",
                                localVarApiClient.escapeString(environmentId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (reason != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("reason", reason));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json", "text/json", "application/*+json"
        };
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"Basic"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postSettingValuesV2ValidateBeforeCall(
            UUID configId,
            UUID environmentId,
            UpdateEvaluationFormulasModel updateEvaluationFormulasModel,
            String reason,
            final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'configId' is set
        if (configId == null) {
            throw new ApiException(
                    "Missing the required parameter 'configId' when calling"
                            + " postSettingValuesV2(Async)");
        }

        // verify the required parameter 'environmentId' is set
        if (environmentId == null) {
            throw new ApiException(
                    "Missing the required parameter 'environmentId' when calling"
                            + " postSettingValuesV2(Async)");
        }

        // verify the required parameter 'updateEvaluationFormulasModel' is set
        if (updateEvaluationFormulasModel == null) {
            throw new ApiException(
                    "Missing the required parameter 'updateEvaluationFormulasModel' when calling"
                            + " postSettingValuesV2(Async)");
        }

        return postSettingValuesV2Call(
                configId, environmentId, updateEvaluationFormulasModel, reason, _callback);
    }

    /**
     * Post values This endpoint batch updates the Feature Flags and Settings of a Config identified
     * by the &#x60;configId&#x60; parameter in a specified Environment identified by the
     * &#x60;environmentId&#x60; parameter. Only those Feature Flags and Settings are updated which
     * are part of the request, all the others are left untouched. **Important:** As this endpoint
     * is doing a complete replace on those Feature Flags and Settings, which are set in the
     * request. It&#39;s important to set every other field that you don&#39;t want to change in its
     * original state. Not listing a field means that it will reset. For example: We have the
     * following resource of a Feature Flag. &#x60;&#x60;&#x60;json { \&quot;settingFormulas\&quot;:
     * [ { \&quot;defaultValue\&quot;: { \&quot;boolValue\&quot;: false },
     * \&quot;targetingRules\&quot;: [ { \&quot;conditions\&quot;: [ { \&quot;userCondition\&quot;:
     * { \&quot;comparisonAttribute\&quot;: \&quot;Email\&quot;, \&quot;comparator\&quot;:
     * \&quot;sensitiveTextEquals\&quot;, \&quot;comparisonValue\&quot;: {
     * \&quot;stringValue\&quot;: \&quot;test@example.com\&quot; } } } ],
     * \&quot;percentageOptions\&quot;: [], \&quot;value\&quot;: { \&quot;boolValue\&quot;: true } }
     * ], \&quot;settingId\&quot;: 1 } ] } &#x60;&#x60;&#x60; If we send a batch replace request
     * body as below: &#x60;&#x60;&#x60;json { \&quot;updateFormulas\&quot;: [ {
     * \&quot;defaultValue\&quot;: { \&quot;boolValue\&quot;: false }, \&quot;settingId\&quot;: 1 }
     * ] } &#x60;&#x60;&#x60; Then besides that the default value is set to &#x60;true&#x60;, all
     * Targeting Rules of the related Feature Flag are deleted. So we get a response like this:
     * &#x60;&#x60;&#x60;json { \&quot;settingFormulas\&quot;: [ { \&quot;defaultValue\&quot;: {
     * \&quot;boolValue\&quot;: false }, \&quot;targetingRules\&quot;: [], \&quot;setting\&quot;: {
     * \&quot;settingId\&quot;: 1 } } ] } &#x60;&#x60;&#x60;
     *
     * @param configId The identifier of the Config. (required)
     * @param environmentId The identifier of the Environment. (required)
     * @param updateEvaluationFormulasModel (required)
     * @param reason The reason note for the Audit Log if the Product&#39;s \&quot;Config changes
     *     require a reason\&quot; preference is turned on. (optional)
     * @return ConfigSettingFormulasModel
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> When everything is ok, the updated setting values returned. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Bad request. </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Not found. </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests. In case of the request rate exceeds the rate limits. </td><td>  -  </td></tr>
     * </table>
     */
    public ConfigSettingFormulasModel postSettingValuesV2(
            UUID configId,
            UUID environmentId,
            UpdateEvaluationFormulasModel updateEvaluationFormulasModel,
            String reason)
            throws ApiException {
        ApiResponse<ConfigSettingFormulasModel> localVarResp =
                postSettingValuesV2WithHttpInfo(
                        configId, environmentId, updateEvaluationFormulasModel, reason);
        return localVarResp.getData();
    }

    /**
     * Post values This endpoint batch updates the Feature Flags and Settings of a Config identified
     * by the &#x60;configId&#x60; parameter in a specified Environment identified by the
     * &#x60;environmentId&#x60; parameter. Only those Feature Flags and Settings are updated which
     * are part of the request, all the others are left untouched. **Important:** As this endpoint
     * is doing a complete replace on those Feature Flags and Settings, which are set in the
     * request. It&#39;s important to set every other field that you don&#39;t want to change in its
     * original state. Not listing a field means that it will reset. For example: We have the
     * following resource of a Feature Flag. &#x60;&#x60;&#x60;json { \&quot;settingFormulas\&quot;:
     * [ { \&quot;defaultValue\&quot;: { \&quot;boolValue\&quot;: false },
     * \&quot;targetingRules\&quot;: [ { \&quot;conditions\&quot;: [ { \&quot;userCondition\&quot;:
     * { \&quot;comparisonAttribute\&quot;: \&quot;Email\&quot;, \&quot;comparator\&quot;:
     * \&quot;sensitiveTextEquals\&quot;, \&quot;comparisonValue\&quot;: {
     * \&quot;stringValue\&quot;: \&quot;test@example.com\&quot; } } } ],
     * \&quot;percentageOptions\&quot;: [], \&quot;value\&quot;: { \&quot;boolValue\&quot;: true } }
     * ], \&quot;settingId\&quot;: 1 } ] } &#x60;&#x60;&#x60; If we send a batch replace request
     * body as below: &#x60;&#x60;&#x60;json { \&quot;updateFormulas\&quot;: [ {
     * \&quot;defaultValue\&quot;: { \&quot;boolValue\&quot;: false }, \&quot;settingId\&quot;: 1 }
     * ] } &#x60;&#x60;&#x60; Then besides that the default value is set to &#x60;true&#x60;, all
     * Targeting Rules of the related Feature Flag are deleted. So we get a response like this:
     * &#x60;&#x60;&#x60;json { \&quot;settingFormulas\&quot;: [ { \&quot;defaultValue\&quot;: {
     * \&quot;boolValue\&quot;: false }, \&quot;targetingRules\&quot;: [], \&quot;setting\&quot;: {
     * \&quot;settingId\&quot;: 1 } } ] } &#x60;&#x60;&#x60;
     *
     * @param configId The identifier of the Config. (required)
     * @param environmentId The identifier of the Environment. (required)
     * @param updateEvaluationFormulasModel (required)
     * @param reason The reason note for the Audit Log if the Product&#39;s \&quot;Config changes
     *     require a reason\&quot; preference is turned on. (optional)
     * @return ApiResponse&lt;ConfigSettingFormulasModel&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> When everything is ok, the updated setting values returned. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Bad request. </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Not found. </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests. In case of the request rate exceeds the rate limits. </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<ConfigSettingFormulasModel> postSettingValuesV2WithHttpInfo(
            UUID configId,
            UUID environmentId,
            UpdateEvaluationFormulasModel updateEvaluationFormulasModel,
            String reason)
            throws ApiException {
        okhttp3.Call localVarCall =
                postSettingValuesV2ValidateBeforeCall(
                        configId, environmentId, updateEvaluationFormulasModel, reason, null);
        Type localVarReturnType = new TypeToken<ConfigSettingFormulasModel>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Post values (asynchronously) This endpoint batch updates the Feature Flags and Settings of a
     * Config identified by the &#x60;configId&#x60; parameter in a specified Environment identified
     * by the &#x60;environmentId&#x60; parameter. Only those Feature Flags and Settings are updated
     * which are part of the request, all the others are left untouched. **Important:** As this
     * endpoint is doing a complete replace on those Feature Flags and Settings, which are set in
     * the request. It&#39;s important to set every other field that you don&#39;t want to change in
     * its original state. Not listing a field means that it will reset. For example: We have the
     * following resource of a Feature Flag. &#x60;&#x60;&#x60;json { \&quot;settingFormulas\&quot;:
     * [ { \&quot;defaultValue\&quot;: { \&quot;boolValue\&quot;: false },
     * \&quot;targetingRules\&quot;: [ { \&quot;conditions\&quot;: [ { \&quot;userCondition\&quot;:
     * { \&quot;comparisonAttribute\&quot;: \&quot;Email\&quot;, \&quot;comparator\&quot;:
     * \&quot;sensitiveTextEquals\&quot;, \&quot;comparisonValue\&quot;: {
     * \&quot;stringValue\&quot;: \&quot;test@example.com\&quot; } } } ],
     * \&quot;percentageOptions\&quot;: [], \&quot;value\&quot;: { \&quot;boolValue\&quot;: true } }
     * ], \&quot;settingId\&quot;: 1 } ] } &#x60;&#x60;&#x60; If we send a batch replace request
     * body as below: &#x60;&#x60;&#x60;json { \&quot;updateFormulas\&quot;: [ {
     * \&quot;defaultValue\&quot;: { \&quot;boolValue\&quot;: false }, \&quot;settingId\&quot;: 1 }
     * ] } &#x60;&#x60;&#x60; Then besides that the default value is set to &#x60;true&#x60;, all
     * Targeting Rules of the related Feature Flag are deleted. So we get a response like this:
     * &#x60;&#x60;&#x60;json { \&quot;settingFormulas\&quot;: [ { \&quot;defaultValue\&quot;: {
     * \&quot;boolValue\&quot;: false }, \&quot;targetingRules\&quot;: [], \&quot;setting\&quot;: {
     * \&quot;settingId\&quot;: 1 } } ] } &#x60;&#x60;&#x60;
     *
     * @param configId The identifier of the Config. (required)
     * @param environmentId The identifier of the Environment. (required)
     * @param updateEvaluationFormulasModel (required)
     * @param reason The reason note for the Audit Log if the Product&#39;s \&quot;Config changes
     *     require a reason\&quot; preference is turned on. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> When everything is ok, the updated setting values returned. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Bad request. </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Not found. </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests. In case of the request rate exceeds the rate limits. </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call postSettingValuesV2Async(
            UUID configId,
            UUID environmentId,
            UpdateEvaluationFormulasModel updateEvaluationFormulasModel,
            String reason,
            final ApiCallback<ConfigSettingFormulasModel> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                postSettingValuesV2ValidateBeforeCall(
                        configId, environmentId, updateEvaluationFormulasModel, reason, _callback);
        Type localVarReturnType = new TypeToken<ConfigSettingFormulasModel>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for replaceSettingValueV2
     *
     * @param environmentId The identifier of the Environment. (required)
     * @param settingId The id of the Setting. (required)
     * @param updateEvaluationFormulaModel (required)
     * @param reason The reason note for the Audit Log if the Product&#39;s \&quot;Config changes
     *     require a reason\&quot; preference is turned on. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Bad request. </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Not found. </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests. In case of the request rate exceeds the rate limits. </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call replaceSettingValueV2Call(
            UUID environmentId,
            Integer settingId,
            UpdateEvaluationFormulaModel updateEvaluationFormulaModel,
            String reason,
            final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updateEvaluationFormulaModel;

        // create path and map variables
        String localVarPath =
                "/v2/environments/{environmentId}/settings/{settingId}/value"
                        .replace(
                                "{" + "environmentId" + "}",
                                localVarApiClient.escapeString(environmentId.toString()))
                        .replace(
                                "{" + "settingId" + "}",
                                localVarApiClient.escapeString(settingId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (reason != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("reason", reason));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json", "text/json", "application/*+json"
        };
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"Basic"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "PUT",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call replaceSettingValueV2ValidateBeforeCall(
            UUID environmentId,
            Integer settingId,
            UpdateEvaluationFormulaModel updateEvaluationFormulaModel,
            String reason,
            final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'environmentId' is set
        if (environmentId == null) {
            throw new ApiException(
                    "Missing the required parameter 'environmentId' when calling"
                            + " replaceSettingValueV2(Async)");
        }

        // verify the required parameter 'settingId' is set
        if (settingId == null) {
            throw new ApiException(
                    "Missing the required parameter 'settingId' when calling"
                            + " replaceSettingValueV2(Async)");
        }

        // verify the required parameter 'updateEvaluationFormulaModel' is set
        if (updateEvaluationFormulaModel == null) {
            throw new ApiException(
                    "Missing the required parameter 'updateEvaluationFormulaModel' when calling"
                            + " replaceSettingValueV2(Async)");
        }

        return replaceSettingValueV2Call(
                environmentId, settingId, updateEvaluationFormulaModel, reason, _callback);
    }

    /**
     * Replace value This endpoint replaces the value and the Targeting Rules of a Feature Flag or
     * Setting in a specified Environment identified by the &lt;a target&#x3D;\&quot;_blank\&quot;
     * rel&#x3D;\&quot;noopener noreferrer\&quot;
     * href&#x3D;\&quot;https://app.configcat.com/sdkkey\&quot;&gt;SDK key&lt;/a&gt; passed in the
     * &#x60;X-CONFIGCAT-SDKKEY&#x60; header. Only the &#x60;defaultValue&#x60;,
     * &#x60;targetingRules&#x60;, and &#x60;percentageEvaluationAttribute&#x60; fields are
     * modifiable by this endpoint. **Important:** As this endpoint is doing a complete replace,
     * it&#39;s important to set every other field that you don&#39;t want to change to its original
     * state. Not listing one means it will reset. For example: We have the following resource of a
     * Feature Flag. &#x60;&#x60;&#x60;json { \&quot;defaultValue\&quot;: { \&quot;boolValue\&quot;:
     * false }, \&quot;targetingRules\&quot;: [ { \&quot;conditions\&quot;: [ {
     * \&quot;userCondition\&quot;: { \&quot;comparisonAttribute\&quot;: \&quot;Email\&quot;,
     * \&quot;comparator\&quot;: \&quot;sensitiveTextEquals\&quot;, \&quot;comparisonValue\&quot;: {
     * \&quot;stringValue\&quot;: \&quot;test@example.com\&quot; } } } ],
     * \&quot;percentageOptions\&quot;: [], \&quot;value\&quot;: { \&quot;boolValue\&quot;: true } }
     * ] } &#x60;&#x60;&#x60; If we send a replace request body as below: &#x60;&#x60;&#x60;json {
     * \&quot;defaultValue\&quot;: { \&quot;boolValue\&quot;: true } } &#x60;&#x60;&#x60; Then
     * besides that the default served value is set to &#x60;true&#x60;, all the Targeting Rules are
     * deleted. So we get a response like this: &#x60;&#x60;&#x60;json { \&quot;defaultValue\&quot;:
     * { \&quot;boolValue\&quot;: true }, \&quot;targetingRules\&quot;: [] } &#x60;&#x60;&#x60;
     *
     * @param environmentId The identifier of the Environment. (required)
     * @param settingId The id of the Setting. (required)
     * @param updateEvaluationFormulaModel (required)
     * @param reason The reason note for the Audit Log if the Product&#39;s \&quot;Config changes
     *     require a reason\&quot; preference is turned on. (optional)
     * @return SettingFormulaModel
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Bad request. </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Not found. </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests. In case of the request rate exceeds the rate limits. </td><td>  -  </td></tr>
     * </table>
     */
    public SettingFormulaModel replaceSettingValueV2(
            UUID environmentId,
            Integer settingId,
            UpdateEvaluationFormulaModel updateEvaluationFormulaModel,
            String reason)
            throws ApiException {
        ApiResponse<SettingFormulaModel> localVarResp =
                replaceSettingValueV2WithHttpInfo(
                        environmentId, settingId, updateEvaluationFormulaModel, reason);
        return localVarResp.getData();
    }

    /**
     * Replace value This endpoint replaces the value and the Targeting Rules of a Feature Flag or
     * Setting in a specified Environment identified by the &lt;a target&#x3D;\&quot;_blank\&quot;
     * rel&#x3D;\&quot;noopener noreferrer\&quot;
     * href&#x3D;\&quot;https://app.configcat.com/sdkkey\&quot;&gt;SDK key&lt;/a&gt; passed in the
     * &#x60;X-CONFIGCAT-SDKKEY&#x60; header. Only the &#x60;defaultValue&#x60;,
     * &#x60;targetingRules&#x60;, and &#x60;percentageEvaluationAttribute&#x60; fields are
     * modifiable by this endpoint. **Important:** As this endpoint is doing a complete replace,
     * it&#39;s important to set every other field that you don&#39;t want to change to its original
     * state. Not listing one means it will reset. For example: We have the following resource of a
     * Feature Flag. &#x60;&#x60;&#x60;json { \&quot;defaultValue\&quot;: { \&quot;boolValue\&quot;:
     * false }, \&quot;targetingRules\&quot;: [ { \&quot;conditions\&quot;: [ {
     * \&quot;userCondition\&quot;: { \&quot;comparisonAttribute\&quot;: \&quot;Email\&quot;,
     * \&quot;comparator\&quot;: \&quot;sensitiveTextEquals\&quot;, \&quot;comparisonValue\&quot;: {
     * \&quot;stringValue\&quot;: \&quot;test@example.com\&quot; } } } ],
     * \&quot;percentageOptions\&quot;: [], \&quot;value\&quot;: { \&quot;boolValue\&quot;: true } }
     * ] } &#x60;&#x60;&#x60; If we send a replace request body as below: &#x60;&#x60;&#x60;json {
     * \&quot;defaultValue\&quot;: { \&quot;boolValue\&quot;: true } } &#x60;&#x60;&#x60; Then
     * besides that the default served value is set to &#x60;true&#x60;, all the Targeting Rules are
     * deleted. So we get a response like this: &#x60;&#x60;&#x60;json { \&quot;defaultValue\&quot;:
     * { \&quot;boolValue\&quot;: true }, \&quot;targetingRules\&quot;: [] } &#x60;&#x60;&#x60;
     *
     * @param environmentId The identifier of the Environment. (required)
     * @param settingId The id of the Setting. (required)
     * @param updateEvaluationFormulaModel (required)
     * @param reason The reason note for the Audit Log if the Product&#39;s \&quot;Config changes
     *     require a reason\&quot; preference is turned on. (optional)
     * @return ApiResponse&lt;SettingFormulaModel&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Bad request. </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Not found. </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests. In case of the request rate exceeds the rate limits. </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<SettingFormulaModel> replaceSettingValueV2WithHttpInfo(
            UUID environmentId,
            Integer settingId,
            UpdateEvaluationFormulaModel updateEvaluationFormulaModel,
            String reason)
            throws ApiException {
        okhttp3.Call localVarCall =
                replaceSettingValueV2ValidateBeforeCall(
                        environmentId, settingId, updateEvaluationFormulaModel, reason, null);
        Type localVarReturnType = new TypeToken<SettingFormulaModel>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Replace value (asynchronously) This endpoint replaces the value and the Targeting Rules of a
     * Feature Flag or Setting in a specified Environment identified by the &lt;a
     * target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;
     * href&#x3D;\&quot;https://app.configcat.com/sdkkey\&quot;&gt;SDK key&lt;/a&gt; passed in the
     * &#x60;X-CONFIGCAT-SDKKEY&#x60; header. Only the &#x60;defaultValue&#x60;,
     * &#x60;targetingRules&#x60;, and &#x60;percentageEvaluationAttribute&#x60; fields are
     * modifiable by this endpoint. **Important:** As this endpoint is doing a complete replace,
     * it&#39;s important to set every other field that you don&#39;t want to change to its original
     * state. Not listing one means it will reset. For example: We have the following resource of a
     * Feature Flag. &#x60;&#x60;&#x60;json { \&quot;defaultValue\&quot;: { \&quot;boolValue\&quot;:
     * false }, \&quot;targetingRules\&quot;: [ { \&quot;conditions\&quot;: [ {
     * \&quot;userCondition\&quot;: { \&quot;comparisonAttribute\&quot;: \&quot;Email\&quot;,
     * \&quot;comparator\&quot;: \&quot;sensitiveTextEquals\&quot;, \&quot;comparisonValue\&quot;: {
     * \&quot;stringValue\&quot;: \&quot;test@example.com\&quot; } } } ],
     * \&quot;percentageOptions\&quot;: [], \&quot;value\&quot;: { \&quot;boolValue\&quot;: true } }
     * ] } &#x60;&#x60;&#x60; If we send a replace request body as below: &#x60;&#x60;&#x60;json {
     * \&quot;defaultValue\&quot;: { \&quot;boolValue\&quot;: true } } &#x60;&#x60;&#x60; Then
     * besides that the default served value is set to &#x60;true&#x60;, all the Targeting Rules are
     * deleted. So we get a response like this: &#x60;&#x60;&#x60;json { \&quot;defaultValue\&quot;:
     * { \&quot;boolValue\&quot;: true }, \&quot;targetingRules\&quot;: [] } &#x60;&#x60;&#x60;
     *
     * @param environmentId The identifier of the Environment. (required)
     * @param settingId The id of the Setting. (required)
     * @param updateEvaluationFormulaModel (required)
     * @param reason The reason note for the Audit Log if the Product&#39;s \&quot;Config changes
     *     require a reason\&quot; preference is turned on. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Bad request. </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Not found. </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests. In case of the request rate exceeds the rate limits. </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call replaceSettingValueV2Async(
            UUID environmentId,
            Integer settingId,
            UpdateEvaluationFormulaModel updateEvaluationFormulaModel,
            String reason,
            final ApiCallback<SettingFormulaModel> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                replaceSettingValueV2ValidateBeforeCall(
                        environmentId, settingId, updateEvaluationFormulaModel, reason, _callback);
        Type localVarReturnType = new TypeToken<SettingFormulaModel>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateSettingValueV2
     *
     * @param environmentId The identifier of the Environment. (required)
     * @param settingId The id of the Setting. (required)
     * @param jsonPatchOperation (required)
     * @param reason The reason note for the Audit Log if the Product&#39;s \&quot;Config changes
     *     require a reason\&quot; preference is turned on. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> When the patch was successful. </td><td>  -  </td></tr>
     * <tr><td> 204 </td><td> When no change applied on the resource. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Bad request. </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Not found. </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests. In case of the request rate exceeds the rate limits. </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateSettingValueV2Call(
            UUID environmentId,
            Integer settingId,
            List<JsonPatchOperation> jsonPatchOperation,
            String reason,
            final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = jsonPatchOperation;

        // create path and map variables
        String localVarPath =
                "/v2/environments/{environmentId}/settings/{settingId}/value"
                        .replace(
                                "{" + "environmentId" + "}",
                                localVarApiClient.escapeString(environmentId.toString()))
                        .replace(
                                "{" + "settingId" + "}",
                                localVarApiClient.escapeString(settingId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (reason != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("reason", reason));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json", "text/json", "application/*+json"
        };
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"Basic"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "PATCH",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateSettingValueV2ValidateBeforeCall(
            UUID environmentId,
            Integer settingId,
            List<JsonPatchOperation> jsonPatchOperation,
            String reason,
            final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'environmentId' is set
        if (environmentId == null) {
            throw new ApiException(
                    "Missing the required parameter 'environmentId' when calling"
                            + " updateSettingValueV2(Async)");
        }

        // verify the required parameter 'settingId' is set
        if (settingId == null) {
            throw new ApiException(
                    "Missing the required parameter 'settingId' when calling"
                            + " updateSettingValueV2(Async)");
        }

        // verify the required parameter 'jsonPatchOperation' is set
        if (jsonPatchOperation == null) {
            throw new ApiException(
                    "Missing the required parameter 'jsonPatchOperation' when calling"
                            + " updateSettingValueV2(Async)");
        }

        return updateSettingValueV2Call(
                environmentId, settingId, jsonPatchOperation, reason, _callback);
    }

    /**
     * Update value This endpoint updates the value of a Feature Flag or Setting with a collection
     * of [JSON Patch](https://jsonpatch.com) operations in a specified Environment. Only the
     * &#x60;defaultValue&#x60;, &#x60;targetingRules&#x60;, and
     * &#x60;percentageEvaluationAttribute&#x60; fields are modifiable by this endpoint. The
     * advantage of using JSON Patch is that you can describe individual update operations on a
     * resource without touching attributes that you don&#39;t want to change. It supports
     * collection reordering, so it also can be used for reordering the targeting rules of a Feature
     * Flag or Setting. For example: We have the following resource of a Feature Flag.
     * &#x60;&#x60;&#x60;json { \&quot;defaultValue\&quot;: { \&quot;boolValue\&quot;: false },
     * \&quot;targetingRules\&quot;: [ { \&quot;conditions\&quot;: [ { \&quot;userCondition\&quot;:
     * { \&quot;comparisonAttribute\&quot;: \&quot;Email\&quot;, \&quot;comparator\&quot;:
     * \&quot;sensitiveTextEquals\&quot;, \&quot;comparisonValue\&quot;: {
     * \&quot;stringValue\&quot;: \&quot;test@example.com\&quot; } } } ],
     * \&quot;percentageOptions\&quot;: [], \&quot;value\&quot;: { \&quot;boolValue\&quot;: true } }
     * ] } &#x60;&#x60;&#x60; If we send an update request body as below: &#x60;&#x60;&#x60;json [ {
     * \&quot;op\&quot;: \&quot;replace\&quot;, \&quot;path\&quot;:
     * \&quot;/targetingRules/0/value/boolValue\&quot;, \&quot;value\&quot;: true } ]
     * &#x60;&#x60;&#x60; Only the first Targeting Rule&#39;s &#x60;value&#x60; is going to be set
     * to &#x60;false&#x60; and all the other fields are remaining unchanged. So we get a response
     * like this: &#x60;&#x60;&#x60;json { \&quot;defaultValue\&quot;: { \&quot;boolValue\&quot;:
     * false }, \&quot;targetingRules\&quot;: [ { \&quot;conditions\&quot;: [ {
     * \&quot;userCondition\&quot;: { \&quot;comparisonAttribute\&quot;: \&quot;Email\&quot;,
     * \&quot;comparator\&quot;: \&quot;sensitiveTextEquals\&quot;, \&quot;comparisonValue\&quot;: {
     * \&quot;stringValue\&quot;: \&quot;test@example.com\&quot; } } } ],
     * \&quot;percentageOptions\&quot;: [], \&quot;value\&quot;: { \&quot;boolValue\&quot;: false }
     * } ] } &#x60;&#x60;&#x60;
     *
     * @param environmentId The identifier of the Environment. (required)
     * @param settingId The id of the Setting. (required)
     * @param jsonPatchOperation (required)
     * @param reason The reason note for the Audit Log if the Product&#39;s \&quot;Config changes
     *     require a reason\&quot; preference is turned on. (optional)
     * @return SettingFormulaModel
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> When the patch was successful. </td><td>  -  </td></tr>
     * <tr><td> 204 </td><td> When no change applied on the resource. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Bad request. </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Not found. </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests. In case of the request rate exceeds the rate limits. </td><td>  -  </td></tr>
     * </table>
     */
    public SettingFormulaModel updateSettingValueV2(
            UUID environmentId,
            Integer settingId,
            List<JsonPatchOperation> jsonPatchOperation,
            String reason)
            throws ApiException {
        ApiResponse<SettingFormulaModel> localVarResp =
                updateSettingValueV2WithHttpInfo(
                        environmentId, settingId, jsonPatchOperation, reason);
        return localVarResp.getData();
    }

    /**
     * Update value This endpoint updates the value of a Feature Flag or Setting with a collection
     * of [JSON Patch](https://jsonpatch.com) operations in a specified Environment. Only the
     * &#x60;defaultValue&#x60;, &#x60;targetingRules&#x60;, and
     * &#x60;percentageEvaluationAttribute&#x60; fields are modifiable by this endpoint. The
     * advantage of using JSON Patch is that you can describe individual update operations on a
     * resource without touching attributes that you don&#39;t want to change. It supports
     * collection reordering, so it also can be used for reordering the targeting rules of a Feature
     * Flag or Setting. For example: We have the following resource of a Feature Flag.
     * &#x60;&#x60;&#x60;json { \&quot;defaultValue\&quot;: { \&quot;boolValue\&quot;: false },
     * \&quot;targetingRules\&quot;: [ { \&quot;conditions\&quot;: [ { \&quot;userCondition\&quot;:
     * { \&quot;comparisonAttribute\&quot;: \&quot;Email\&quot;, \&quot;comparator\&quot;:
     * \&quot;sensitiveTextEquals\&quot;, \&quot;comparisonValue\&quot;: {
     * \&quot;stringValue\&quot;: \&quot;test@example.com\&quot; } } } ],
     * \&quot;percentageOptions\&quot;: [], \&quot;value\&quot;: { \&quot;boolValue\&quot;: true } }
     * ] } &#x60;&#x60;&#x60; If we send an update request body as below: &#x60;&#x60;&#x60;json [ {
     * \&quot;op\&quot;: \&quot;replace\&quot;, \&quot;path\&quot;:
     * \&quot;/targetingRules/0/value/boolValue\&quot;, \&quot;value\&quot;: true } ]
     * &#x60;&#x60;&#x60; Only the first Targeting Rule&#39;s &#x60;value&#x60; is going to be set
     * to &#x60;false&#x60; and all the other fields are remaining unchanged. So we get a response
     * like this: &#x60;&#x60;&#x60;json { \&quot;defaultValue\&quot;: { \&quot;boolValue\&quot;:
     * false }, \&quot;targetingRules\&quot;: [ { \&quot;conditions\&quot;: [ {
     * \&quot;userCondition\&quot;: { \&quot;comparisonAttribute\&quot;: \&quot;Email\&quot;,
     * \&quot;comparator\&quot;: \&quot;sensitiveTextEquals\&quot;, \&quot;comparisonValue\&quot;: {
     * \&quot;stringValue\&quot;: \&quot;test@example.com\&quot; } } } ],
     * \&quot;percentageOptions\&quot;: [], \&quot;value\&quot;: { \&quot;boolValue\&quot;: false }
     * } ] } &#x60;&#x60;&#x60;
     *
     * @param environmentId The identifier of the Environment. (required)
     * @param settingId The id of the Setting. (required)
     * @param jsonPatchOperation (required)
     * @param reason The reason note for the Audit Log if the Product&#39;s \&quot;Config changes
     *     require a reason\&quot; preference is turned on. (optional)
     * @return ApiResponse&lt;SettingFormulaModel&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> When the patch was successful. </td><td>  -  </td></tr>
     * <tr><td> 204 </td><td> When no change applied on the resource. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Bad request. </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Not found. </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests. In case of the request rate exceeds the rate limits. </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<SettingFormulaModel> updateSettingValueV2WithHttpInfo(
            UUID environmentId,
            Integer settingId,
            List<JsonPatchOperation> jsonPatchOperation,
            String reason)
            throws ApiException {
        okhttp3.Call localVarCall =
                updateSettingValueV2ValidateBeforeCall(
                        environmentId, settingId, jsonPatchOperation, reason, null);
        Type localVarReturnType = new TypeToken<SettingFormulaModel>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update value (asynchronously) This endpoint updates the value of a Feature Flag or Setting
     * with a collection of [JSON Patch](https://jsonpatch.com) operations in a specified
     * Environment. Only the &#x60;defaultValue&#x60;, &#x60;targetingRules&#x60;, and
     * &#x60;percentageEvaluationAttribute&#x60; fields are modifiable by this endpoint. The
     * advantage of using JSON Patch is that you can describe individual update operations on a
     * resource without touching attributes that you don&#39;t want to change. It supports
     * collection reordering, so it also can be used for reordering the targeting rules of a Feature
     * Flag or Setting. For example: We have the following resource of a Feature Flag.
     * &#x60;&#x60;&#x60;json { \&quot;defaultValue\&quot;: { \&quot;boolValue\&quot;: false },
     * \&quot;targetingRules\&quot;: [ { \&quot;conditions\&quot;: [ { \&quot;userCondition\&quot;:
     * { \&quot;comparisonAttribute\&quot;: \&quot;Email\&quot;, \&quot;comparator\&quot;:
     * \&quot;sensitiveTextEquals\&quot;, \&quot;comparisonValue\&quot;: {
     * \&quot;stringValue\&quot;: \&quot;test@example.com\&quot; } } } ],
     * \&quot;percentageOptions\&quot;: [], \&quot;value\&quot;: { \&quot;boolValue\&quot;: true } }
     * ] } &#x60;&#x60;&#x60; If we send an update request body as below: &#x60;&#x60;&#x60;json [ {
     * \&quot;op\&quot;: \&quot;replace\&quot;, \&quot;path\&quot;:
     * \&quot;/targetingRules/0/value/boolValue\&quot;, \&quot;value\&quot;: true } ]
     * &#x60;&#x60;&#x60; Only the first Targeting Rule&#39;s &#x60;value&#x60; is going to be set
     * to &#x60;false&#x60; and all the other fields are remaining unchanged. So we get a response
     * like this: &#x60;&#x60;&#x60;json { \&quot;defaultValue\&quot;: { \&quot;boolValue\&quot;:
     * false }, \&quot;targetingRules\&quot;: [ { \&quot;conditions\&quot;: [ {
     * \&quot;userCondition\&quot;: { \&quot;comparisonAttribute\&quot;: \&quot;Email\&quot;,
     * \&quot;comparator\&quot;: \&quot;sensitiveTextEquals\&quot;, \&quot;comparisonValue\&quot;: {
     * \&quot;stringValue\&quot;: \&quot;test@example.com\&quot; } } } ],
     * \&quot;percentageOptions\&quot;: [], \&quot;value\&quot;: { \&quot;boolValue\&quot;: false }
     * } ] } &#x60;&#x60;&#x60;
     *
     * @param environmentId The identifier of the Environment. (required)
     * @param settingId The id of the Setting. (required)
     * @param jsonPatchOperation (required)
     * @param reason The reason note for the Audit Log if the Product&#39;s \&quot;Config changes
     *     require a reason\&quot; preference is turned on. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> When the patch was successful. </td><td>  -  </td></tr>
     * <tr><td> 204 </td><td> When no change applied on the resource. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Bad request. </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Not found. </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests. In case of the request rate exceeds the rate limits. </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateSettingValueV2Async(
            UUID environmentId,
            Integer settingId,
            List<JsonPatchOperation> jsonPatchOperation,
            String reason,
            final ApiCallback<SettingFormulaModel> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                updateSettingValueV2ValidateBeforeCall(
                        environmentId, settingId, jsonPatchOperation, reason, _callback);
        Type localVarReturnType = new TypeToken<SettingFormulaModel>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
